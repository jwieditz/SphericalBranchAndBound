#' Branch computes a subdivision of a triangle.
#'
#' @param D A triangle.
#' @param INIT generates from SET a list with the following attributes
#' - size
#' - upper bound (ub)
#' - lower bound (lb)
#'
#' @return A list of triangles generated by INIT.
#' @author Johannes Wieditz

branch.sphere <- function ( D, INIT, ... ){

  d12 <- darc.sphere( D$d1 , D$d2 )
  d13 <- darc.sphere( D$d1 , D$d3 )
  d23 <- darc.sphere( D$d2 , D$d3 )

  if( d12 == max( d12, d13, d23 )  ) {

    c( INIT( list(
      list( d1 = D$d1, d2 = norm.vec(D$d1+D$d2), d3 = D$d3 ),
      list( d1 = norm.vec(D$d1 + D$d2), d2 = D$d2, d3 = D$d3 ))
      )
    )

  } else if( d13 == max( d12, d13, d23 ) ){

    c( INIT( list(
      list( d1 = D$d1, d2 = D$d2, d3 = norm.vec(D$d1 + D$d3) ),
      list( d1 = norm.vec(D$d1 + D$d3), d2 = D$d2, d3 = D$d3 ))
      )
    )

  } else

    c( INIT( list(
      list( d1 = D$d1, d2 = D$d2, d3 = norm.vec(D$d2 + D$d3) ) ,
      list( d1 = D$d1, d2 = norm.vec(D$d2 + D$d3), d3 = D$d3 ) )
      )
    )
}

#' Computes the midpoint of a triangle.
#'
#' @param D triangle
#'
#' @result The midpoint of the triangle D.
#' @author Johannes Wieditz

mid.sphere <- function ( D ){

  m <- ( D$d1 + D$d2 + D$d3 )/3
  m <- norm.vec(m)

}

#' The arc length metric on the 2-sphere.
#'
#' @param x A point on the 2-sphere.
#' @param y A point on the 2-sphere.
#'
#' @result The arc length distance between x and y.
#' @author Johannes Wieditz

darc.sphere <- function ( x, y ) {

  dotprod <- x %*% y
  if( abs( dotprod ) >= 1 ){
    if( sign( dotprod ) == 1 ) 0 else pi

  } else acos( dotprod )

}

#' Numerically more stable version of the arcsine of the modulus of the dot product of x and y.
#'
#' @param x A point on the 2-sphere.
#' @param y A point on the 2-sphere.
#'
#' @result The arcsine of the modulus of the dot product of x and y.
#' @author Johannes Wieditz

arcsin <- function ( x, y ) {

  dotprod <- abs( x %*% y )
  if( dotprod >= 1 ) pi/2 else asin( dotprod )

}

#' Compute the circumradius of a triangle.
#'
#' @param D A spherical triangle.
#'
#' @return The circumradius of the (plane) triangle induced by the vertices of D.
#' @author Johannes Wieditz

size.triangle <- function ( D ) {

  max( darc.sphere( D$d1, D$d2 ),
       darc.sphere( D$d1, D$d3 ),
       darc.sphere( D$d2, D$d3 )
  )
}


#' Normalise a vector.
#'
#' @param vector A vector.
#'
#' @return The corresponding unit vector for the passed input. If the input is the origin, we return the origin again.
#' @author Johannes Wieditz
#' @export

norm.vec <- function( vector ){

  if( sum(vector^2) != 0){
    return( 1/sqrt( sum( vector^2) ) * vector)
  }
  else{
    return( rep(0, length(vector)) )
  }
}

#' Initialise a list with set entries and lower bound using the triangle inequality.
#'
#' @param set A list of elements to initialise.
#'
#' @result A list where every entry consists of the entries
#' * set description
#' * size as circumradius
#' * upper bound as function value at the midpoint
#' * lower bound using triangle inequality
#' @author Johannes Wieditz

init.3ineq.sphere <- function( set, ... ) {

  L <- list()
  for( X in set ){
    f <- Fnhat( mid.sphere(X), d = darc.sphere )
    L <- push(L, c(X, size = size.triangle(X), ub = f , lb = f - p * pi^(p-1) * size.triangle(X) ))
  }
  L
}

#' Initialise a list with set entries and the exact lower bound.
#'
#' @param set A list of elements to initialise.
#'
#' @result A list where every entry consists of the entries
#' * set description
#' * size as circumradius
#' * upper bound as function value at the midpoint
#' * lower bound as exact (maximal) lower bound on this set
#' @author Johannes Wieditz

init.acc.sphere <- function( set, ... ) {

  L <- list()
  for( X in set ){
    f <- 0

    n12 <- norm.vec(X$d1 %x% X$d2)
    if( n12 %*% X$d3 < 0) n12 <- -n12
    n23 <- norm.vec(X$d2 %x% X$d3)
    if( n23 %*% X$d1 < 0) n23 <- -n23
    n31 <- norm.vec(X$d3 %x% X$d1)
    if( n31 %*% X$d2 < 0) n31 <- -n31

    QR12 <- qr(matrix( c( X$d1 , X$d2 , -n12 ), nrow = 3 ))
    Q12 <- qr.Q(QR12)
    R12 <- qr.R(QR12)

    QR23 <- qr(matrix( c( X$d2 , X$d3 , -n23 ), nrow = 3 ))
    Q23 <- qr.Q(QR23)
    R23 <- qr.R(QR23)

    QR31 <- qr(matrix( c( X$d3 , X$d1 , -n31 ), nrow = 3 ))
    Q31 <- qr.Q(QR31)
    R31 <- qr.R(QR31)

    for( xi in x ){
      g <- 0

      if( !is.in.Delta.scalprods(n12, n23, n31, xi) ){

        if( is.in.Lambda.qr(Q12, R12, xi) )

          g12 <- arcsin( xi, -n12 )

        else g12 <- min( darc.sphere(xi, X$d1), darc.sphere(xi, X$d2) )

        if( is.in.Lambda.qr(Q23, R23, xi))

          g23 <- arcsin( xi, -n23 )

        else g23 <- min( darc.sphere(xi, X$d2), darc.sphere(xi, X$d3) )

        if( is.in.Lambda.qr(Q31, R31, xi) )

          g31 <- arcsin( xi, -n31 )

        else g31 <- min( darc.sphere(xi, X$d3), darc.sphere(xi, X$d1) )

        g <- min( g12, g23, g31 )

      }
      f <- f + g^p
    }
    f <- 1/length(x) * f
    L <- push( L, c(X, size = size.triangle(X), ub =  Fnhat(mid.sphere(X), d = darc.sphere), lb = f ) )
  }
  L
}

#' The crossproduct of the 3D vectors.
#'
#' @param a A 3-dimensional vector.
#' @param b A 3-dimensional vector.
#'
#' @result The cross product of a and b.
#' @author Johannes Wieditz

`%x%` <- function ( a, b ){

  c( a[[2]]*b[[3]] - a[[3]]*b[[2]], a[[3]]*b[[1]] - a[[1]]*b[[3]], a[[1]]*b[[2]] - a[[2]]*b[[1]])

}

#' Check whether a point is contained in a triangle by solving a linear equation.
#'
#' @param Q The Q matrix of a QR decomposition of the matrix D = (d1, d2, d3) induced by the vertices of the triangle.
#' @param R The corresponding R matrix.
#' @param y The point to be checked whether it is inside D.
#'
#' @result TRUE or FALSE depending on whether y is in D or not.
#' @author Johannes Wieditz


is.in.Delta.qr <- function( Q, R, y ){

  X <- backsolve( R, t(Q)%*%y )
  if( X[[1]] >= 0 && X[[2]] >= 0 && X[[3]] >= 0) TRUE else FALSE
}

#' Check whether a point is contained in a triangle by computing scalar products.
#'
#' @param n12 @param n23 @param n31 The normal vectors induced by the vertices of the triangle D.
#' @param y The point to be checked whether it is inside D.
#'
#' @result TRUE or FALSE depending on whether y is in D or not.
#' @author Johannes Wieditz

is.in.Delta.scalprods <- function( n12, n23, n31, y ){

  if( (y %*% n12) >= 0 && (y %*% n23) >= 0 && (y %*% n31) >= 0) TRUE else FALSE
}


#' Check whether a point is contained in a spherical lune.
#'
#' @param Q The Q matrix of a QR decomposition of the matrix Lambda = Lambda(d1, d2) induced by the vertices of the spherical lune.
#' @param R The corresponding R matrix.
#' @param y The point to be checked whether it is inside Lambda.
#'
#' @result TRUE or FALSE depending on whether y is in D or not.
#' @author Johannes Wieditz

is.in.Lambda.qr <- function( Q, R, y ){

  X <- backsolve( R, t(Q)%*%y )
  if( X[[1]] >= 0 && X[[2]] >= 0 ) TRUE else FALSE
}

#' Compute spherical coordinates of a 3D vector given in cartesian coordinates.
#'
#' @param y A 3D vector.
#'
#' @result The spherical coordinates of y.
#' @author Johannes Wieditz
#'
#' @export

get.angles <- function( y ){

  list(theta = acos(y[[3]]), phi = atan2(y[[2]], y[[1]]))

}

#' Compute geographical spherical coordinates of a 3D vector given in cartesian coordinates.
#'
#' @param y A 3D vector.
#'
#' @result The geographical spherical coordinates of y.
#' @author Johannes Wieditz
#'
#' @export

get.angles.geo <- function( y ){

  list(theta = pi / 2 - acos(y[[3]]), phi = atan2(y[[2]], y[[1]]))

}


#' Compute the cartesian coordinates of a 3D vector given in spherical coordinates.
#'
#' @param y A 3D vector.
#'
#' @result The geographical spherical coordinates of y.
#' @author Johannes Wieditz
#'
#' @export

get.vector <- function( theta = 0, phi = 0 ){

  c( sin(theta)*sin(phi), sin(theta)*cos(phi), cos(theta) )

}

#' Computes the surface measure of a list of spherical triangles relative to the whole surface.
#'
#' @param A A list of spherical triangles.
#'
#' @result The percentage of the surface of the 2-sphere covered by the triangles in the list A.
#' @author Johannes Wieditz

size.sphere <- function( A ){

  size <- 0
  for( X in A ){

    size <- size + darc.sphere( norm.vec(X$d1 %x% X$d2), norm.vec(X$d1 %x% X$d3) ) + darc.sphere( norm.vec(X$d2 %x% X$d3), norm.vec(X$d2 %x% X$d1) ) + darc.sphere( norm.vec(X$d3 %x% X$d1), norm.vec(X$d3 %x% X$d2) ) - pi
  }
  size / ( 4 * pi ) * 100
}

#' Plot the computed (eps, delta)-approximation on a 3D object.
#'
#' @param A The computed (eps, delta)-approximation.
#' @param data The input data as list of cartesian coordinates.
#'
#' 
#'
#' @result A plot-object of the passed list.
#'
#' @author Johannes Wieditz
#'
#' @export

draw.eps.delta.approximation <- function( A, data ){

  library(rgl)
  library(sphereplot)
  library(alphashape3d)
  
  coords.list <- matrix(data = NA, nrow = length(A$output), ncol = 3)

  for( i in 1:length(A$output) ){
    coords.list[i,1] <- A$output[[i]]$d1[1]
    coords.list[i,2] <- A$output[[i]]$d1[2]
    coords.list[i,3] <- A$output[[i]]$d1[3]
  }

  input.coords <- matrix(data = NA, nrow = length(data), ncol = 2)

  for( i in 1:length(data)){

    input.coords[i,1] <- get.angles.geo(data[[i]])[[1]]
    input.coords[i,2] <- get.angles.geo(data[[i]])[[2]]
  }

  toplot <- matrix( data = NA, nrow = length(A$toplot) + 6, ncol = 3)

  for( i in 1:length(A$toplot)){

    toplot[i,1] <- A$toplot[[i]][1]
    toplot[i,2] <- A$toplot[[i]][2]
    toplot[i,3] <- A$toplot[[i]][3]

  }

  toplot[ length(A$toplot) + 1 , ] <- c(1,0,0)
  toplot[ length(A$toplot) + 2 , ] <- c(-1,0,0)
  toplot[ length(A$toplot) + 3 , ] <- c(0,1,0)
  toplot[ length(A$toplot) + 4 , ] <- c(0,-1,0)
  toplot[ length(A$toplot) + 5 , ] <- c(0,0,1)
  toplot[ length(A$toplot) + 6 , ] <- c(0,0,-1)

  rgl.sphgrid(radius = 1, col.long='red', col.lat='blue', deggap = 30, longtype = "D", add = FALSE, radaxis=F)
  rgl.sphpoints(input.coords[,1], input.coords[,2], 1, deg = FALSE , col='black', size = 10, bg = "white")

  plot(ashape3d(toplot, alpha = .5), byComponents = FALSE, indexAlpha = "all", col = c(rgb(1, 1, 1, 0), "black", "black"), clear = FALSE, transparency = .25 )
  plot(ashape3d(coords.list, alpha = .5), byComponents = FALSE, indexAlpha = "all", col = c("red","red","red"), clear = FALSE,  transparency = 1)

  return()
}



